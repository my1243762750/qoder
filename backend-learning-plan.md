## 后端学习与实战项目总计划

> 目标：以一个「迷你 Jira（团队任务与缺陷管理系统）」为主线，在实战中系统学习 Java 后端开发，并覆盖常见面试考点。你主要做「理解 + 决策 + 检查」，具体写代码的活可以交给 AI。

---

## 1. 总体说明

### 1.1 项目整体目标

- **实战目标**：完成一个按「线上可用」标准设计的任务及缺陷管理系统，而不是简单的 Todo Demo。
- **学习目标**：
  - 夯实 Java Web 后端基础（Spring Boot、HTTP、JPA、SQL 等）。
  - 掌握典型业务能力：用户系统、权限、项目管理、任务流转、附件、通知。
  - 理解生产级非功能需求：安全、性能、日志监控、部署等。
  - 覆盖后端常见面试话题：事务、锁、缓存、消息队列、限流、API 设计、测试等。
- **协作方式**：
  - 你：负责理解需求、做技术/业务取舍、阅读和检查代码、亲自运行和调试。
  - AI：根据你的指令，生成具体代码、配置文件、SQL、测试用例等。

### 1.2 Sprint / 阶段划分

本计划按「由浅到深」分为 5 个阶段，你可以按周或按你自己的节奏推进：

- **阶段 0：环境搭建 & 入门体验**（1～2 天）
- **阶段 1：MVP——最小可用版本（账号 + 项目 + 任务基础）**（1～2 周）
- **阶段 2：业务加强 & 权限控制**（1～2 周）
- **阶段 3：性能 & 工程化（缓存、异步、文件、监控、Docker）**（约 2 周）
- **阶段 4：高级后端 & 面试深挖（事务、锁、分布式思维、测试）**（2+ 周）

你可以把每个阶段当作一个「小迭代」，只要该阶段的任务完成，就能看到明显的能力提升和产品进化。

---

## 2. 技术栈选型

### 2.1 后端技术

- **语言**：Java 17
- **框架**：Spring Boot 3.x
- **Web 层**：Spring MVC（Spring Web）
- **持久化**：Spring Data JPA + MySQL
- **缓存**：Redis
- **消息队列**：RabbitMQ（也可未来升级为 Kafka）
- **安全**：Spring Security + JWT
- **文档**：Springdoc OpenAPI（Swagger UI）
- **监控**：Spring Boot Actuator
- **构建工具**：Maven
- **容器化**：Docker / Docker Compose

### 2.2 前端技术

- **框架**：Vue 3 + Vite
- **UI 库**：Element Plus（或你熟悉的其他组件库）
- **网络请求**：Axios

> 说明：前端主要为了「能看到效果 + 调后端接口」，你本身是前端出身，可以根据喜好调整技术栈，但计划默认按 Vue 3 编写。

---

## 3. 产品与非功能需求

### 3.1 产品功能概览（迷你 Jira）

- **用户 & 权限**
  - 用户注册 / 登录。
  - 角色：普通成员、项目管理员、系统管理员。
- **项目管理**
  - 创建、编辑、归档项目。
  - 管理项目成员（邀请 / 移除）。
- **任务 / 缺陷（Issue）管理**
  - 在项目下创建任务 / 缺陷，设置标题、描述、优先级、状态、指派人等。
  - 状态流转：Open → In Progress → Resolved → Closed。
  - 评论、附件上传。
- **视图**
  - 列表视图：支持过滤、排序、分页。
  - 后期可扩展为看板视图（按状态分列，拖拽任务）。

### 3.2 非功能需求（贯穿整个计划）

- **安全**
  - JWT 鉴权、角色权限控制。
  - 密码加密存储（BCrypt）。
  - 防越权访问（只允许访问自己有权限的项目 / 任务）。
- **可靠性**
  - 关键操作使用事务管理。
  - 对幂等敏感的接口考虑幂等策略。
- **性能**
  - 合理的索引和 SQL 设计。
  - Redis 缓存热点数据（项目列表、任务列表等）。
- **可维护性**
  - 清晰分层：Controller → Service → Repository → Domain。
  - DTO 与 Entity 分离，避免直接暴露实体给前端。
  - 统一错误响应格式和错误码设计。
- **可观测性**
  - 统一日志格式（包含 traceId / userId 等关键信息）。
  - 健康检查与基础监控（Actuator）。
- **可部署性**
  - 多环境配置：dev、prod。
  - Docker 化：应用 + MySQL + Redis + RabbitMQ。
- **测试**
  - Service 层单元测试。
  - API 集成测试（含 DB）。


---

## 4. 阶段规划总览

### 4.1 阶段 0：环境搭建 & 入门体验

- 搭好开发环境，能跑起一个简单的 Spring Boot + MySQL 项目。
- 初步了解 Controller、Service、Repository 分层与简单 CRUD。

### 4.2 阶段 1：MVP——最小可用版本

- 实现：注册 / 登录 / 项目创建 / 查看自己的项目 / 项目下创建和查看任务。
- 前端可以完整走通「登录 → 创建项目 → 创建任务 → 查看任务」。
- 初步掌握 JWT、基本表设计、基础 REST API 设计。

### 4.3 阶段 2：业务加强 & 权限控制

- 加强任务流转、筛选、分页、排序。
- 实现项目成员机制与权限控制（谁能访问 / 操作什么）。
- 引入 DTO、审计字段，提升代码结构和可维护性。

### 4.4 阶段 3：性能 & 工程化

- 导入 Redis 缓存、异步任务（通知）、消息队列（RabbitMQ）。
- 实现文件上传功能（附件）。
- 引入 Actuator、统一日志；完成 Docker 化与简单编排。

### 4.5 阶段 4：高级后端 & 面试深挖

- 专门针对事务、锁、限流、测试、API 版本等常见面试问题做强化实践。
- 通过已有项目讲述系统设计和技术方案。


---

## 5. 阶段 0：环境搭建 & 入门体验（1～2 天）

### 5.1 学习目标

- 完成 Java + Spring Boot + MySQL 的基本开发环境搭建。
- 能运行一个简单的 REST 接口和数据库 CRUD。

### 5.2 产出物

- 一个可以启动的 Spring Boot 项目：
  - 包含一个简单实体（比如 DemoUser）。
  - 一个简单 Controller，可以返回 JSON。
  - 项目成功连上本地 MySQL，完成一次读写。

### 5.3 具体任务清单

1. **安装与配置**
   - 安装 JDK 17。
   - 安装 Maven。
   - 安装 IntelliJ IDEA。
   - 安装并启动 MySQL（可用 Docker 或本地安装）。
   - 安装 Redis（可以先装好，后续阶段使用）。

2. **创建项目骨架**
   - 让 AI 帮你：
     - 通过 Spring Initializr 生成一个基础项目（包括 Web、JPA、MySQL 依赖）。
     - 给出 `application-dev.yml` 的样例配置（数据库连接）。
   - 你：
     - 把配置填好（用户名密码、库名），并在本地创建对应数据库。

3. **实现一个简单 Demo**
   - 让 AI 生成：
     - 一个简单实体（如 DemoUser）。
     - 对应的 Repository。
     - 一个测试用 Controller：
       - `GET /api/demo/hello` 返回一段 JSON 文本。
       - `POST /api/demo/users` 写入一条用户数据到 MySQL。
   - 你：
     - 启动项目，使用 Postman 或浏览器/前端简单调用接口。

4. **理解基本结构**
   - 弄清楚：Controller → Service → Repository 各做什么。
   - 弄清楚：`@Entity`、`@Id`、`@GeneratedValue` 等注解的含义。

> 提示：这一阶段不必纠结细节，主要是「能跑、能改、敢动手」。


---

## 6. 阶段 1：MVP——账号 + 项目 + 任务基础（1～2 周）

### 6.1 学习目标

- 实现最小可用系统：用户注册登录、项目管理、任务基础 CRUD。
- 掌握基本表设计、JWT 登录、REST API 的常见模式。

### 6.2 产出物

- 实体与数据表：User、Project、Issue。
- 接口：
  - 注册 `/api/auth/register`。
  - 登录 `/api/auth/login`。
  - 创建项目 `/api/projects`，查看项目列表 `/api/projects`。
  - 在项目下创建任务 `/api/projects/{projectId}/issues`，查看任务列表 `/api/projects/{projectId}/issues`。
- 前端：
  - 登录 / 注册页面。
  - 项目列表页面。
  - 项目详情页面（任务列表 + 创建任务弹窗）。

### 6.3 具体任务清单

#### 6.3.1 表结构与实体设计

1. 让 AI 帮你设计并生成：
   - `User` 实体：
     - 字段：id, email, username, passwordHash, role, createdAt, updatedAt。
   - `Project` 实体：
     - 字段：id, name, description, ownerId, createdAt, updatedAt。
   - `Issue` 实体：
     - 字段：id, title, description, status, priority, projectId, assigneeId, createdAt, updatedAt。
2. 要求：
   - 使用 JPA 注解（`@Entity`、`@ManyToOne` 等）描述关联。
   - 让 AI 顺带给出建表 SQL（方便你理解 DB 结构）。

#### 6.3.2 用户注册与登录（JWT）

1. 让 AI 实现：
   - `AuthController`：
     - `POST /api/auth/register`：接收注册信息，保存用户（密码加密）。
     - `POST /api/auth/login`：验证用户名/邮箱 + 密码，成功后返回 JWT。
   - `AuthService`：
     - 包含密码加密、用户校验逻辑。
   - JWT 工具类：
     - 生成 Token、解析 Token、获取用户信息等。
2. 你需要重点理解：
   - 密码为什么要加密存储（BCrypt）。
   - JWT 的结构（header.payload.signature）。
   - 为什么采用无状态认证（不在服务端维护 Session）。

#### 6.3.3 项目基础 CRUD

1. 让 AI 实现：
   - `ProjectController`：
     - `POST /api/projects`：创建项目（默认当前登录用户为 owner）。
     - `GET /api/projects`：返回当前用户相关项目列表。
   - `ProjectService`：封装业务逻辑，如当前用户只能看到自己相关的项目。
2. 要求：
   - 使用 Spring Security 拦截，保证只有登录用户可以创建 / 查看项目。
   - 所有接口返回统一 JSON 结构（如 { code, message, data }）。

#### 6.3.4 任务（Issue）基础 CRUD

1. 让 AI 实现：
   - `IssueController`：
     - `POST /api/projects/{projectId}/issues`：在指定项目下创建任务。
     - `GET /api/projects/{projectId}/issues`：获取项目下任务列表。
   - `IssueService`：封装创建、查询逻辑。
2. 要求：
   - 创建任务时自动设置默认状态（如 Open）。
   - 初期列表可不做分页，随后在阶段 2 加入。

#### 6.3.5 前后端打通

1. 前端（Vue）：
   - 实现登录 / 注册表单，调用后端接口。
   - 登录成功后保存 Token（localStorage 或 pinia/vuex）。
   - 请求时在 header 中带上 `Authorization: Bearer <token>`。
   - 实现项目列表、项目详情 + 简单任务创建和展示。
2. 你可让 AI：
   - 帮你写 Vue 的 API 封装模块（Axios 实例、拦截器）。
   - 帮你写基础页面骨架和组件（你再调整样式）。

### 6.4 本阶段知识点（面试向）

- RESTful API 设计（路径、方法、状态码）。
- Spring MVC 基础（Controller、RequestMapping）。
- Spring Data JPA 基本用法（CRUD、关系映射）。
- 数据库表设计（一对多、多对一）。
- 密码加密与 JWT 认证的基本原理。


---

## 7. 阶段 2：业务加强 & 权限控制（1～2 周）

### 7.1 学习目标

- 从「能用」升级为「业务规则清晰、安全可控」的系统。
- 学会分页、排序、筛选、权限控制、审计字段、DTO 分离等。

### 7.2 产出物

- 更丰富的任务管理：状态流转、筛选、分页、排序。
- 完整的项目成员机制：只有项目成员才能访问项目及任务。
- DTO 层与审计字段的引入。

### 7.3 具体任务清单

#### 7.3.1 任务流转与筛选

1. 增强 Issue：
   - 状态枚举：Open, InProgress, Resolved, Closed。
   - 优先级枚举：Low, Medium, High, Critical。
2. 接口增强：
   - 支持修改任务状态与优先级。
   - 任务列表支持：
     - 按状态筛选。
     - 按优先级筛选。
     - 按创建时间排序。
     - 支持分页（page, pageSize）。
3. 让 AI：
   - 根据你的分页和筛选需求，写出 JPA 查询代码（方法命名查询或 `@Query`）。

#### 7.3.2 项目成员与权限

1. 数据结构：
   - 新建 `ProjectMember` 表：projectId, userId, roleInProject。
2. 接口：
   - 项目 owner 可以邀请成员加入项目。
   - 项目 owner 可以移除成员。
3. 权限控制：
   - 只有项目成员可以访问项目和项目下的任务。
   - 只有项目 owner 可以删除项目或修改项目设定。
4. 让 AI：
   - 使用 Spring Security 的 `@PreAuthorize` 或在 Service 层写明确的权限判断。

#### 7.3.3 DTO 与审计字段

1. 引入审计字段：
   - 对主要实体（User, Project, Issue）添加 createdAt、updatedAt、createdBy、updatedBy。
   - 使用 Spring Data JPA Auditing 或手动在 Service 层填充。
2. DTO 分离：
   - 为 Project、Issue 定义 RequestDTO / ResponseDTO。
   - 不直接返回 JPA 实体给前端。
3. 让 AI：
   - 给出 DTO、Entity 之间的 Mapper（手写或 MapStruct）。

### 7.4 本阶段知识点（面试向）

- 分页、排序、筛选的实现与 API 设计。
- JPA 查询方法、`@Query`、关联查询基础。
- RBAC 权限模型与 Spring Security 的常见用法。
- 审计字段和可追踪性。
- DTO vs Entity 的区别和好处。


---

## 8. 阶段 3：性能 & 工程化（2 周左右）

### 8.1 学习目标

- 引入缓存、异步、消息队列等，提高性能和可扩展性。
- 增加文件上传、监控、日志规范、Docker 化，向“可上线”靠近。

### 8.2 产出物

- 使用 Redis 缓存部分查询结果，并处理缓存失效。
- 使用 `@Async` 和 RabbitMQ 发送任务变更通知。
- 支持任务附件上传和下载。
- 集成 Actuator、统一日志格式；项目可以 Docker 运行。

### 8.3 具体任务清单

#### 8.3.1 引入 Redis 缓存

1. 使用 Redis 缓存：
   - 项目列表。
   - 某项目的任务列表（可根据筛选条件选择性缓存）。
2. 缓存策略：
   - 读：先查缓存，缓存没有再查数据库并写入缓存。
   - 写：新增/修改/删除项目或任务时，清理相关缓存。
3. 让 AI：
   - 使用 Spring Cache 或手写 Redis 操作实现上述逻辑。

#### 8.3.2 异步通知与消息队列

1. 业务场景：
   - 当任务被指派给某人，或状态发生变更时，发送通知（模拟邮件或站内消息）。
2. 实现步骤：
   - 第一阶段：使用 `@Async` 异步执行发送通知（先写日志模拟）。
   - 第二阶段：引入 RabbitMQ：
     - 任务变更时发送消息到队列。
     - 独立消费者监听队列，处理通知逻辑。
3. 让 AI：
   - 编写 RabbitMQ 配置、生产者和消费者代码。

#### 8.3.3 文件上传（附件）

1. 支持为任务上传附件：
   - 支持多文件上传。
   - 元数据（文件名、大小、类型、存储路径）保存到数据库。
2. 存储策略：
   - 先使用本地文件系统存储（如 `uploads/` 目录）。
   - 预留扩展点未来可换为云存储（如 OSS / S3）。
3. 前端：
   - 任务详情页支持上传和展示附件列表。

#### 8.3.4 监控 & 日志 & Docker 化

1. Actuator：
   - 暴露 `/actuator/health`、`/actuator/info` 等端点。
2. 日志：
   - 统一日志格式，包含时间、级别、traceId、userId 等。
   - 可以在请求入口生成 traceId，并通过 MDC 传递。
3. Docker：
   - 为后端编写 Dockerfile。
   - 编写 docker-compose.yml，将：
     - 应用 + MySQL + Redis + RabbitMQ 一起启动。

### 8.4 本阶段知识点（面试向）

- Redis 缓存使用与常见问题（缓存穿透 / 击穿 / 雪崩）。
- 异步与消息队列的作用和基本用法。
- 文件上传 / 下载处理、存储方案。
- 健康检查、监控指标、日志规范。
- Docker 容器化的基本实践。


---

## 9. 阶段 4：高级后端 & 面试深挖（2+ 周）

### 9.1 学习目标

- 在已有系统上实践事务、锁、限流、测试、API 版本等高级话题。
- 为面试准备「可讲的项目经历 + 细节实现」。

### 9.2 产出物

- 若干个针对面试问题的「专题实现」：
  - 事务管理与回滚。
  - 乐观锁 / 悲观锁并发控制。
  - Redis 限流。
  - 完整的 Service 单元测试。
  - 若干集成测试。
  - 一个 v2 版本的 API。

### 9.3 具体任务清单

#### 9.3.1 事务管理

1. 找出一个多步骤业务场景：
   - 例如：创建任务 + 写审计日志 + 发送领域事件。
2. 使用 `@Transactional` 包裹，并模拟各种异常：
   - 某一步失败时，确保整体回滚。
   - 分析不同异常类型（受检异常 / 非受检异常）的影响。
3. 让 AI：
   - 展示事务传播（Propagation）的典型用法，并举例说明。

#### 9.3.2 并发与锁

1. 乐观锁：
   - 在 Issue 上添加 `version` 字段（`@Version`）。
   - 模拟两个并发请求修改同一任务，观察冲突。
   - 设计处理策略（提示用户、重试等）。
2. 悲观锁：
   - 为一个对一致性要求很高的操作使用数据库悲观锁（`select ... for update`）。
3. 让 AI：
   - 编写示例代码和测试用例，演示并发场景。

#### 9.3.3 限流与防护

1. 选一个接口（如登录）做限流：
   - 使用 Redis + Lua 或自增策略实现简单限流。
   - 超过限制时返回友好错误。
2. 了解 Web 安全基础：
   - CSRF、XSS、SQL 注入的基本概念与防御方式（在现有代码中体现）。

#### 9.3.4 测试体系

1. 单元测试：
   - 使用 Mockito 为 Service 层编写若干单元测试。
2. 集成测试：
   - 使用 SpringBootTest + Testcontainers（或内存数据库）编写接口级测试。

#### 9.3.5 API 版本化

1. 选一个关键接口（例如任务详情）：
   - 保留 v1 版本。
   - 新增 v2 版本，返回更丰富或不同结构的数据。
2. 在代码中体现 API 版本的演进策略。

### 9.4 本阶段知识点（面试向）

- 事务：ACID、事务传播、隔离级别概念及 Spring 实践。
- 并发控制：乐观锁与悲观锁的适用场景和实现方法。
- 限流策略：令牌桶 / 漏桶模型（概念）+ Redis 实践。
- 测试：单元测试与集成测试的意义与写法。
- API 版本化策略。


---

## 10. 如何使用这份计划

1. **按阶段推进**：
   - 一次专注一个阶段，不要同时做太多事情。
   - 每完成一个阶段，回顾一下：我学到了哪些知识？可以回答哪些面试问题？

2. **与 AI 协作的建议用法**：
   - 对于每个小任务：
     - 先自己用「自然语言」描述清楚要做什么（可以直接复制本文件中的任务描述）。
     - 让 AI：
       - 帮你设计 / 修改表结构和实体。
       - 生成完整的 Controller / Service / Repository 代码。
       - 给出必要的配置（如 yml、Dockerfile）。
     - 你：
       - 把代码整合到本地项目，运行、调试、通过接口测试。
       - 有问题再把报错信息 / 代码片段丢给 AI 帮你排查。

3. **面试准备建议**：
   - 每完成一个阶段，写一小段「阶段总结」：
     - 做了什么功能？
     - 遇到了什么问题？
     - 做了哪些技术选型？为什么？
   - 面试前，可以让 AI 帮你：
     - 把整个项目的设计和技术方案整理为一份「项目介绍稿」。
     - 按常见面试题来“对你进行项目深挖模拟”。

> 从现在开始，你可以把本文件当成「总计划书」。每次要做什么，只需要从当前阶段的任务里挑一条出来，然后让 AI 和你一起把这条任务做完即可。
